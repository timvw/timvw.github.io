<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Drafts on Tim Van Wassenhove</title>
    <link>/draft/</link>
    <description>Recent content in Drafts on Tim Van Wassenhove</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/draft/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>/draft/openshift_v4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/draft/openshift_v4/</guid>
      <description>Openshift Authenticate etc&amp;hellip; oc login &amp;ndash;server=https://api.us-east-1.online-starter.openshift.com:6443 oc status oc project fun
Source-to-image Source-to-Image (S2I) build
Getting started with Java S2I
oc new-app &amp;ndash;image-stream=java:11 &amp;ndash;code=https://github.com/timvw/oc-jvm.git
More fun oc create imagestream demo
oc new-build &amp;ndash;name demo-docker &amp;ndash;strategy docker &amp;ndash;binary &amp;ndash;docker-image centos:centos7 &amp;ndash;to demo
-&amp;gt; docker builds are not allowed on &amp;ldquo;redhat openshift online&amp;rdquo;
As alternative, build docker image locally and push then to registry
https://docs.openshift.com/container-platform/4.1/registry/securing-exposing-registry.html
Manual toying around&amp;hellip; oc create -f https://gist.githubusercontent.com/tqvarnst/3ca512b01b7b7c1a1da0532939350e23/raw/3869a54c7dd960965f0e66907cdc3eba6d160cad/openjdk-s2i-imagestream.json</description>
    </item>
    
    <item>
      <title>Introduction to Akka</title>
      <link>/draft/introduction-to-akka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/draft/introduction-to-akka/</guid>
      <description>Functional programming is all about immutable data and pure functions.
Akka is nothing like that.
The core concept in Akka is an Actor that handles messages (function invocations).
Here is how this looks like in practice:
trait Actor { type Receive = PartialFunction[Any, Unit] def receive: Actor.Receive } As you can see there is nothing pure about the receive function (It is a PartialFunction returning Unit).
In order to call the receive function you have to send the actor a message via it&amp;rsquo;s !</description>
    </item>
    
    <item>
      <title>Leverage Terraform, Azure Container Service and kaniko to create and use container images on Kubernetes.</title>
      <link>/draft/building/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/draft/building/</guid>
      <description>In this post I demonstrate how easy it has become to build and use container images on Kubernetes (without docker) leveraging kaniko.
In order to follow along you should clone the sample code from this repository:
git clone https://github.com/timvw/sample-terraform-azure-k8s-acr-kaniko Create an Azure Container Registry with Terraform
terraform init terraform apply -auto-approve We will use the admin credentials to create a docker registry secret:
kubectl create secret docker-registry acr-secret \  --namespace default \  --docker-server=https://$(terraform output cr_server) \  --docker-username=$(terraform output cr_admin_username) \  --docker-password=$(terraform output cr_admin_password) Now we can build an image on our cluster and push it to our container registry:</description>
    </item>
    
    <item>
      <title>Railway Oriented Programming in Scala</title>
      <link>/draft/railway-oriented-programming-in-scala/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/draft/railway-oriented-programming-in-scala/</guid>
      <description>Some years ago scott wrote the awesome https://fsharpforfunandprofit.com/posts/recipe-part2/.</description>
    </item>
    
  </channel>
</rss>
