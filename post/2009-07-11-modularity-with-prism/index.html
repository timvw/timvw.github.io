<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Small modification to achieve better modularity with Prism - Tim Van Wassenhove</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Small modification to achieve better modularity with Prism">
<meta itemprop="description" content="I have been experimenting with WPF and Prism (Composite Application Guidance for WPF and Silverlight) and ran into a major issue: modularity. Here is an excerpt from the documentation
 Modules have explicit boundaries, typically by subsystem or feature. Having these boundaries makes it easier for separate teams to develop modules. On large applications, teams may be organized by cross-cutting capabilities in addition to being organized by a specific subsystem or feature.">
<meta itemprop="datePublished" content="2009-07-11T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-01-04T14:56:32+01:00" />
<meta itemprop="wordCount" content="256">



<meta itemprop="keywords" content="C#," />
<meta property="og:title" content="Small modification to achieve better modularity with Prism" />
<meta property="og:description" content="I have been experimenting with WPF and Prism (Composite Application Guidance for WPF and Silverlight) and ran into a major issue: modularity. Here is an excerpt from the documentation
 Modules have explicit boundaries, typically by subsystem or feature. Having these boundaries makes it easier for separate teams to develop modules. On large applications, teams may be organized by cross-cutting capabilities in addition to being organized by a specific subsystem or feature." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://timvw.be/post/2009-07-11-modularity-with-prism/" />
<meta property="article:published_time" content="2009-07-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-04T14:56:32+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Small modification to achieve better modularity with Prism"/>
<meta name="twitter:description" content="I have been experimenting with WPF and Prism (Composite Application Guidance for WPF and Silverlight) and ran into a major issue: modularity. Here is an excerpt from the documentation
 Modules have explicit boundaries, typically by subsystem or feature. Having these boundaries makes it easier for separate teams to develop modules. On large applications, teams may be organized by cross-cutting capabilities in addition to being organized by a specific subsystem or feature."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://timvw.be/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://timvw.be/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://timvw.be/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://timvw.be/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
	<h1 class="site-title"><a href="https://timvw.be/">Tim Van Wassenhove</a></h1>
	<div class="site-description"><nav class="nav social">
			<ul class="flat"><li><a href="https://twitter.com/timvw" title="Twitter"><i data-feather="twitter"></i></a></li><li><a href="https://github.com/timvw" title="Github"><i data-feather="github"></i></a></li><li><a href="https://www.linkedin.com/in/timvanwassenhove" title="Linkedin"><i data-feather="linkedin"></i></a></li><li><a href="https://timvw.be/feed.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="../../">Home</a>
			</li>
			
			<li>
				<a href="../../post">All posts</a>
			</li>
			
			<li>
				<a href="../../tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">11</span>
							<span class="rest">Jul 2009</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Small modification to achieve better modularity with Prism</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>I have been experimenting with WPF and Prism (<a href="http://msdn.microsoft.com/en-us/library/cc707819.aspx">Composite Application Guidance for WPF and Silverlight</a>) and ran into a major issue: modularity. Here is an excerpt from the documentation</p>
<blockquote>
<p>Modules have explicit boundaries, typically by subsystem or feature. Having these boundaries makes it easier for separate teams to develop modules. On large applications, teams may be organized by cross-cutting capabilities in addition to being organized by a specific subsystem or feature. For example, there may be a team assigned to shared components of the application, such as the shell or the common infrastructure module.</p>
</blockquote>
<p>The Modularity quick start solution uses the DirectoryModuleCatalog to discover modules. The module projects have a build event that copy their output to a single Modules folder</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">xcopy &#34;$(TargetDir)*.*&#34; &#34;$(SolutionDir)DirectoryLookupModularity\$(OutDir)Modules\&#34; /Y
</code></pre></div><p>This means that if two modules output a file with the same name, one of the two will get lost :(. In order to avoid this we create a directory per module</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">xcopy &#34;$(TargetDir)*.*&#34; &#34;$(SolutionDir)DirectoryLookupModularity\$(OutDir)Modules\$(TargetName)\&#34; /Y
</code></pre></div><p>To make this work we have to modify the catalog a little</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#000;font-weight:bold">protected</span> <span style="color:#000;font-weight:bold">override</span> <span style="color:#000;font-weight:bold">void</span> InnerLoad()
{
	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#458;font-weight:bold">string</span>.IsNullOrEmpty(<span style="color:#000;font-weight:bold">this</span>.ModulePath))
		<span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> InvalidOperationException(Resources.ModulePathCannotBeNullOrEmpty);

	<span style="color:#000;font-weight:bold">if</span> (!Directory.Exists(<span style="color:#000;font-weight:bold">this</span>.ModulePath))
		<span style="color:#000;font-weight:bold">throw</span> <span style="color:#000;font-weight:bold">new</span> InvalidOperationException(<span style="color:#458;font-weight:bold">string</span>.Format(CultureInfo.CurrentCulture, Resources.DirectoryNotFound, <span style="color:#000;font-weight:bold">this</span>.ModulePath));

	<span style="color:#000;font-weight:bold">foreach</span> (<span style="color:#458;font-weight:bold">var</span> assemblyFile <span style="color:#000;font-weight:bold">in</span> Directory.GetFiles(<span style="color:#000;font-weight:bold">this</span>.ModulePath, <span style="color:#d14">&#34;*.dll&#34;</span>, SearchOption.AllDirectories))
	{
		<span style="color:#458;font-weight:bold">var</span> privateBinPath = Path.GetFullPath(Path.GetDirectoryName(assemblyFile));
		<span style="color:#458;font-weight:bold">var</span> childDomain = <span style="color:#000;font-weight:bold">this</span>.BuildChildDomain(AppDomain.CurrentDomain, privateBinPath);

		<span style="color:#000;font-weight:bold">try</span>
		{
			<span style="color:#458;font-weight:bold">var</span> loaderType = <span style="color:#000;font-weight:bold">typeof</span>(InnerModuleInfoLoader);
			<span style="color:#000;font-weight:bold">if</span> (loaderType.Assembly == <span style="color:#000;font-weight:bold">null</span>) <span style="color:#000;font-weight:bold">continue</span>;
			<span style="color:#458;font-weight:bold">var</span> loader = (InnerModuleInfoLoader)childDomain.CreateInstanceFromAndUnwrap(loaderType.Assembly.Location, loaderType.FullName);
			loader.LoadAssembly(assemblyFile);
			<span style="color:#000;font-weight:bold">this</span>.Items.AddRange(loader.GetModuleInfos());
		}		
		<span style="color:#000;font-weight:bold">finally</span>
		{
			AppDomain.Unload(childDomain);
		}
	}
}
</code></pre></div><p>As long as we don&rsquo;t use (unsigned and different) assembly files with the same name in different modules we will have a working solution.</p>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="../../tags/C">C#</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2021  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-2585435-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
