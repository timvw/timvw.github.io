<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Making WebRequests in parallel... - Tim Van Wassenhove</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Making WebRequests in parallel...">
<meta itemprop=description content="Under the assumption that making sequential WebRequests is slower than making them in parallel i wrote a little program that returns the HTTP status code for each URI in a list. Because the number of WaitHandles on a system is limited to 64 and i would have been required to hack around this limitation i decided to use ThreadPool instead&mldr;
using System; using System.Collections.Generic; using System.Text; using System.Threading; using System.Net; namespace ManyRequests { class Program { static void Main(string[] args) { List<uri> uris = new List<uri>(); uris."><meta itemprop=datePublished content="2007-01-14T00:00:00+00:00">
<meta itemprop=dateModified content="2021-01-04T22:47:36+01:00">
<meta itemprop=wordCount content="328">
<meta itemprop=keywords content="CSharp,"><meta property="og:title" content="Making WebRequests in parallel...">
<meta property="og:description" content="Under the assumption that making sequential WebRequests is slower than making them in parallel i wrote a little program that returns the HTTP status code for each URI in a list. Because the number of WaitHandles on a system is limited to 64 and i would have been required to hack around this limitation i decided to use ThreadPool instead&mldr;
using System; using System.Collections.Generic; using System.Text; using System.Threading; using System.Net; namespace ManyRequests { class Program { static void Main(string[] args) { List<uri> uris = new List<uri>(); uris.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://timvw.be/2007/01/14/making-webrequests-in-parallel.../"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2007-01-14T00:00:00+00:00">
<meta property="article:modified_time" content="2021-01-04T22:47:36+01:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Making WebRequests in parallel...">
<meta name=twitter:description content="Under the assumption that making sequential WebRequests is slower than making them in parallel i wrote a little program that returns the HTTP status code for each URI in a list. Because the number of WaitHandles on a system is limited to 64 and i would have been required to hack around this limitation i decided to use ThreadPool instead&mldr;
using System; using System.Collections.Generic; using System.Text; using System.Threading; using System.Net; namespace ManyRequests { class Program { static void Main(string[] args) { List<uri> uris = new List<uri>(); uris.">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css>
<link rel=stylesheet type=text/css media=screen href=https://timvw.be/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://timvw.be/css/main.css>
<link id=dark-scheme rel=stylesheet type=text/css href=https://timvw.be/css/dark.css>
<script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script>
<script src=https://timvw.be/js/main.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<h1 class=site-title><a href=https://timvw.be/>Tim Van Wassenhove</a></h1>
<div class=site-description><p>Passionate geek, interested in Technology. Proud father of two</p><nav class="nav social">
<ul class=flat><li><a href=https://twitter.com/timvw title=Twitter><i data-feather=twitter></i></a></li><li><a href=https://github.com/timvw title=Github><i data-feather=github></i></a></li><li><a href=https://www.linkedin.com/in/timvanwassenhove title=Linkedin><i data-feather=linkedin></i></a></li><li><a href=https://timvw.be/feed.xml title=RSS><i data-feather=rss></i></a></li></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
<li>
<a href=../../../../>Home</a>
</li>
<li>
<a href=../../../../posts>All posts</a>
</li>
<li>
<a href=../../../../tags>Tags</a>
</li>
</ul>
</nav>
</div>
<div class=post>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>14</span>
<span class=rest>Jan 2007</span>
</div>
</div>
<div class=matter>
<h1 class=title>Making WebRequests in parallel...</h1>
</div>
</div>
<div class=markdown>
<p>Under the assumption that making sequential WebRequests is slower than making them in parallel i wrote a little program that returns the HTTP status code for each URI in a list. Because the number of WaitHandles on a system is limited to 64 and i would have been required to hack around this limitation i decided to use ThreadPool instead&mldr;</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#000;font-weight:700>using</span> <span style=color:#555>System</span>;
<span style=color:#000;font-weight:700>using</span> <span style=color:#555>System.Collections.Generic</span>;
<span style=color:#000;font-weight:700>using</span> <span style=color:#555>System.Text</span>;
<span style=color:#000;font-weight:700>using</span> <span style=color:#555>System.Threading</span>;
<span style=color:#000;font-weight:700>using</span> <span style=color:#555>System.Net</span>;

<span style=color:#000;font-weight:700>namespace</span> <span style=color:#555>ManyRequests</span>
{
	<span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>Program</span>
	{
	
		<span style=color:#000;font-weight:700>static</span> <span style=color:#000;font-weight:700>void</span> Main(<span style=color:#458;font-weight:700>string</span>[] args)
		{
			List&lt;uri&gt; uris = <span style=color:#000;font-weight:700>new</span> List&lt;uri&gt;();
			uris.Add(<span style=color:#000;font-weight:700>new</span> Uri(<span style=color:#d14>&#34;http://www.timvw.be&#34;</span>));
			uris.Add(<span style=color:#000;font-weight:700>new</span> Uri(<span style=color:#d14>&#34;http://example.com/does\_not\_exist&#34;</span>));
			uris.Add(<span style=color:#000;font-weight:700>new</span> Uri(<span style=color:#d14>&#34;http://www.timvw.be/c-sharp&#34;</span>));
			uris.Add(<span style=color:#000;font-weight:700>new</span> Uri(<span style=color:#d14>&#34;http://www.timvw.be/rss-feed/&#34;</span>));
			uris.Add(<span style=color:#000;font-weight:700>new</span> Uri(<span style=color:#d14>&#34;http://localhost&#34;</span>));

		Console.WriteLine(<span style=color:#d14>&#34;Getting the HttpStatusCodes...&#34;</span>);
		HttpStatusCodeReader httpStatusCodeReader = <span style=color:#000;font-weight:700>new</span> HttpStatusCodeReader(uris);
		<span style=color:#458;font-weight:700>int</span>[] httpStatusCodes = httpStatusCodeReader.GetHttpStatusCodes();

		<span style=color:#000;font-weight:700>for</span> (<span style=color:#458;font-weight:700>int</span> i = <span style=color:#099>0</span>; i &lt; uris.Count; ++i) 
		{ 
			Console.WriteLine(<span style=color:#d14>&#34;{0} {1}&#34;</span>, httpStatusCodes[i], uris[i]); }
			Console.Write(<span style=color:#d14>&#34;{0}Press any key to continueâ€¦&#34;</span>, Environment.NewLine); 
			Console.ReadKey(); 
		} 
	} 
	
	<span style=color:#000;font-weight:700>public</span> <span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>HttpStatusCodeReader</span> 
	{ 
		<span style=color:#000;font-weight:700>private</span> List&lt;uri&gt; uris;
		<span style=color:#000;font-weight:700>private</span> <span style=color:#458;font-weight:700>int</span>[] httpStatusCodes;
		<span style=color:#000;font-weight:700>private</span> <span style=color:#458;font-weight:700>object</span> syncLock;
		<span style=color:#000;font-weight:700>private</span> <span style=color:#458;font-weight:700>int</span> completed;

		<span style=color:#000;font-weight:700>public</span> HttpStatusCodeReader(List&lt;uri&gt; uris)
		{
			<span style=color:#000;font-weight:700>if</span> (uris == <span style=color:#000;font-weight:700>null</span>)
			{
				<span style=color:#000;font-weight:700>throw</span> <span style=color:#000;font-weight:700>new</span> ArgumentNullException(<span style=color:#d14>&#34;uris&#34;</span>);
			}

			<span style=color:#000;font-weight:700>foreach</span> (Uri uri <span style=color:#000;font-weight:700>in</span> uris)
			{
				<span style=color:#000;font-weight:700>if</span> (uri.Scheme != Uri.UriSchemeHttp &amp;&amp; uri.Scheme != Uri.UriSchemeHttps)
				{
					<span style=color:#000;font-weight:700>throw</span> <span style=color:#000;font-weight:700>new</span> ArgumentException(uri.ToString() + <span style=color:#d14>&#34; is not valid http(s) uri.&#34;</span>, <span style=color:#d14>&#34;uris&#34;</span>);
				}
			}

			<span style=color:#000;font-weight:700>this</span>.uris = uris;
			<span style=color:#000;font-weight:700>this</span>.httpStatusCodes = <span style=color:#000;font-weight:700>new</span> <span style=color:#458;font-weight:700>int</span>[uris.Count];
			<span style=color:#000;font-weight:700>this</span>.syncLock = <span style=color:#000;font-weight:700>new</span> <span style=color:#458;font-weight:700>object</span>();
			<span style=color:#000;font-weight:700>this</span>.completed = <span style=color:#099>0</span>;
		}

		<span style=color:#000;font-weight:700>public</span> <span style=color:#458;font-weight:700>int</span>[] GetHttpStatusCodes()
		{
			<span style=color:#000;font-weight:700>for</span> (<span style=color:#458;font-weight:700>int</span> i = <span style=color:#099>0</span>; i &lt; <span style=color:#000;font-weight:700>this</span>.httpStatusCodes.Length; ++i) 
			{ 
				HttpWebRequest httpWebRequest = WebRequest.Create(<span style=color:#000;font-weight:700>this</span>.uris[i]) <span style=color:#000;font-weight:700>as</span> HttpWebRequest; 
				httpWebRequest.Method = <span style=color:#d14>&#34;HEAD&#34;</span>; 
				httpWebRequest.AllowAutoRedirect = <span style=color:#000;font-weight:700>true</span>; 
				httpWebRequest.BeginGetResponse(<span style=color:#000;font-weight:700>this</span>.GetResponseCompleted, <span style=color:#000;font-weight:700>new</span> <span style=color:#458;font-weight:700>object</span>[] { httpWebRequest, i });
			} 
			<span style=color:#000;font-weight:700>lock</span> (<span style=color:#000;font-weight:700>this</span>.syncLock) 
			{ 
				<span style=color:#000;font-weight:700>while</span> (<span style=color:#000;font-weight:700>this</span>.completed &lt; <span style=color:#000;font-weight:700>this</span>.httpStatusCodes.Length) 
				{ 
					Monitor.Wait(<span style=color:#000;font-weight:700>this</span>.syncLock); 
				} 
			} 
			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>this</span>.httpStatusCodes; 
		} 
		
		<span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>void</span> GetResponseCompleted(IAsyncResult ar) 
		{ 
			<span style=color:#458;font-weight:700>object</span>[] objects = ar.AsyncState <span style=color:#000;font-weight:700>as</span> <span style=color:#458;font-weight:700>object</span>[];
			HttpWebRequest httpWebRequest = objects[<span style=color:#099>0</span>] <span style=color:#000;font-weight:700>as</span> HttpWebRequest; 
			<span style=color:#458;font-weight:700>int</span> index = (<span style=color:#458;font-weight:700>int</span>)objects[<span style=color:#099>1</span>]; 
			HttpWebResponse httpWebResponse = <span style=color:#000;font-weight:700>null</span>; 
			<span style=color:#000;font-weight:700>try</span> 
			{
				httpWebResponse = httpWebRequest.EndGetResponse(ar) <span style=color:#000;font-weight:700>as</span> HttpWebResponse; 
				<span style=color:#000;font-weight:700>this</span>.httpStatusCodes[index] = (<span style=color:#458;font-weight:700>int</span>)httpWebResponse.StatusCode; 
			} 
			<span style=color:#000;font-weight:700>catch</span> (WebException webException) 
			{ 
				httpWebResponse = webException.Response <span style=color:#000;font-weight:700>as</span> HttpWebResponse; 
				<span style=color:#000;font-weight:700>if</span> (httpWebResponse != <span style=color:#000;font-weight:700>null</span>) 
				{ 
					<span style=color:#000;font-weight:700>this</span>.httpStatusCodes[index] = (<span style=color:#458;font-weight:700>int</span>)httpWebResponse.StatusCode; 
				} 
			} 
			<span style=color:#000;font-weight:700>finally</span> 
			{ 
				<span style=color:#000;font-weight:700>if</span> (httpWebResponse != <span style=color:#000;font-weight:700>null</span>) 
				{ 
					httpWebResponse.Close(); 
				} 
				<span style=color:#000;font-weight:700>lock</span> (<span style=color:#000;font-weight:700>this</span>.syncLock) 
				{ 
					Interlocked.Add(<span style=color:#000;font-weight:700>ref</span> <span style=color:#000;font-weight:700>this</span>.completed, <span style=color:#099>1</span>); 
					Monitor.Pulse(<span style=color:#000;font-weight:700>this</span>.syncLock); 
				} 
			}
		} 
	} 
}
</code></pre></div>
</div>
<div class=tags>
<ul class=flat>
<li><a href=../../../../tags/csharp>CSharp</a></li>
</ul>
</div></div>
</div>
<div class="footer wrapper">
<nav class=nav>
<div>2022 <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-2585435-1','auto'),ga('send','pageview'))</script><script>feather.replace()</script>
</body>
</html>