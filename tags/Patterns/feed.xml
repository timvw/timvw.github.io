<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Patterns on Tim Van Wassenhove</title>
    <link>/tags/Patterns/</link>
    <description>Recent content in Patterns on Tim Van Wassenhove</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Jan 2010 00:00:00 +0000</lastBuildDate><atom:link href="/tags/Patterns/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Presenting ValueType&lt;T&gt;</title>
      <link>/post/2010-01-28-presenting-valuetypet/</link>
      <pubDate>Thu, 28 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-01-28-presenting-valuetypet/</guid>
      <description>Here is a base class for some code that i have written once too many in my life: (In case you&amp;rsquo;re an early adaptor (.Net 4.0) you may want to use System.Tupleas base class)
public class ValueType&amp;lt;T&amp;gt; : IComparable, IComparable&amp;lt;valueType&amp;lt;T&amp;gt;&amp;gt;, IEquatable&amp;lt;valueType&amp;lt;T&amp;gt;&amp;gt; where T : IComparable&amp;lt;T&amp;gt; { protected T Value { get; private set; } public ValueType(T value) { Value = value; } public override int GetHashCode() { return Value.GetHashCode(); } public override string ToString() { return Value.</description>
    </item>
    
    <item>
      <title>Do we need an EventAggregator when we have an IOC container?</title>
      <link>/post/2010-01-27-do-we-need-an-eventaggregator-when-we-have-an-ioc-container/</link>
      <pubDate>Wed, 27 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-01-27-do-we-need-an-eventaggregator-when-we-have-an-ioc-container/</guid>
      <description>An Event Aggregator is an example of a Publish/Subscribe channel. A while ago i started wondering if we still need an Event Aggregator in our compisite applications if we have an IOC container that takes cares of dependency wiring. An IOC container can easily inject the Event/MessageHandler(s) in the Event/MessagePublisher(s)&amp;hellip; I&amp;rsquo;m still not sure about the answer (Yes/No).</description>
    </item>
    
    <item>
      <title>Creating series of elements</title>
      <link>/post/2010-01-08-creating-series-of-elements/</link>
      <pubDate>Fri, 08 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-01-08-creating-series-of-elements/</guid>
      <description>Lately i have done quite a bit of charting. Very often the X-axis is populated with a series of numbers or dates. This can be as simple as: (My very little DSL in Jeremy D. Miller Style)
[Test] public void ShouldBeAbleToGetSeriesOfNumbers() { // Arrange 	var series = 3.To(5); // Act 	var elements = series.Elements; // Assert 	var expected = new[] { 3, 4, 5 }; CollectionAssert.AreEqual(expected, elements); } [Test] public void ShouldBeAbleToGetSeriesOfDays() { // Arrange 	var now = DateTime.</description>
    </item>
    
    <item>
      <title>In case you really have to Append one array to another</title>
      <link>/post/2009-12-04-in-case-you-really-have-to-append-one-array-to-another/</link>
      <pubDate>Fri, 04 Dec 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-12-04-in-case-you-really-have-to-append-one-array-to-another/</guid>
      <description>Here is another problem i&amp;rsquo;ve seen people solve once too many: Append one array to another. STOP. Revisit the problem. Can&amp;rsquo;t you simply use Listand move on to solving actual business problems? In case you really can&amp;rsquo;t get rid of the arrays read the following
Given() { source = new[] { SourceElement }; destination = new[] { DestinationElement }; } and
When() { source.AppendTo(ref destination); } and
ThenTheDestinationShouldStillHaveTheDestinationElement() { Assert.AreEqual(DestinationElement, destination[0]); } and</description>
    </item>
    
    <item>
      <title>About databinding and composite views</title>
      <link>/post/2009-10-13-about-databinding-and-composite-views/</link>
      <pubDate>Tue, 13 Oct 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-10-13-about-databinding-and-composite-views/</guid>
      <description>A couple of days ago i had a databound ItemsControl (collection of Model.Cell) which instantiated sub views (with their own viewmodel).
&amp;lt;grid&amp;gt; &amp;lt;grid.Resources&amp;gt; &amp;lt;dataTemplate x:Key=&amp;#34;CellTemplate&amp;#34;&amp;gt; &amp;lt;views:CellView /&amp;gt; &amp;lt;/dataTemplate&amp;gt; &amp;lt;/grid.Resources&amp;gt; &amp;lt;itemsControl ItemTemplate=&amp;#34;{StaticResource CellTemplate}&amp;#34; ItemsSource=&amp;#34;{Binding Cells}&amp;#34; /&amp;gt; &amp;lt;/grid&amp;gt; Because each CellViewModel needs to know which cell they manage i used the following dirty hack
public CellView() { Loaded += CellView_Loaded; } void CellView_Loaded(object sender, RoutedEventArgs e) { DataContext = new CellViewModel(DataContext); } Later on that day i realised there was a much cleaner solution: Let the BoardViewModel expose a collection of ViewModels.</description>
    </item>
    
    <item>
      <title>Exploring M-V-VM</title>
      <link>/post/2009-10-13-exploring-m-v-vm/</link>
      <pubDate>Tue, 13 Oct 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-10-13-exploring-m-v-vm/</guid>
      <description>A couple of years ago a collegue recommended Data Binding with Windows Forms 2.0: Programming Smart Client Data Applications with .NET and i noticed that my code started to gravitate towards an Model-View-ViewModel architecture. Due to shortcomings and painful experiences i gave up on databinding and began to use Passieve View instead.
Passive View doesn&amp;rsquo;t work (well) with smart views so i decided to give M-V-VM another because i really wanted to leverage WPF&amp;rsquo;s rich support for databinding.</description>
    </item>
    
    <item>
      <title>Extension methods to improve readability</title>
      <link>/post/2009-08-28-extension-methods-to-improve-readability/</link>
      <pubDate>Fri, 28 Aug 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-08-28-extension-methods-to-improve-readability/</guid>
      <description>A common reason to take advantage of extension methods is to enhance readability (think fluent interfaces). My team uses the specification pattern regularly and in case a requirement says something like &amp;ldquo;if the player has reached level 10 a message should be displayed&amp;rdquo; they would implement it as
if (new HasReachedLevel(10).IsSatisfiedBy(player)) { view.DisplayMessage(&amp;#34;Congratulations! You have reached level 10.&amp;#34;); } Pretty good but did you notice that they changed the order of player and level in their (code) story?</description>
    </item>
    
    <item>
      <title>Experimenting with ControlStateMachine and Fluent interfaces</title>
      <link>/post/2009-08-13-experimenting-with-controlstatemachine-and-fluent-interfaces/</link>
      <pubDate>Thu, 13 Aug 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-08-13-experimenting-with-controlstatemachine-and-fluent-interfaces/</guid>
      <description>A long time ago i read Build your own CAB series and recently i noticed that there is a wiki: Presentation Patterns Wiki! and it inspired me to experiment with state machines. Here are a couple of examples:
controlStateMachine = new ControlStateMachine&amp;lt;states&amp;gt;(this); controlStateMachine.AfterEachStateChange() .Do(MakeRelevantButtonsVisible); controlStateMachine.WhenStateChangesTo(States.RetrievingSubscriptionPeriod) .TheOnlyVisibleControlsAre(flowLayoutPanel1, datePicker1); controlStateMachine.WhenStateChangesTo(States.RetrievingCustomerInformation) .MakeVisible(customerInput1) .Do(() =&amp;gt; customerInput1.Dock = DockStyle.Fill); controlStateMachine.WhenStateChangesTo(States.Ready) .MakeInvisible(customerInput1); And here is another example:
wizardStateMachine = new WizardStateMachine&amp;lt;states&amp;gt;(controlStateMachine); wizardStateMachine.InState(States.RetrievingSubscriptionPeriod) .OnCommand(WizardCommands.Next) .TransitionTo(States.RetrievingCustomerInformation); wizardStateMachine.InState(States.RetrievingCustomerInformation) .OnCommand(WizardCommands.Back) .</description>
    </item>
    
    <item>
      <title>Strict mocks lead to overspecification</title>
      <link>/post/2009-03-24-strict-mocks-lead-to-overspecification/</link>
      <pubDate>Tue, 24 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-03-24-strict-mocks-lead-to-overspecification/</guid>
      <description>Here is an example that demonstrates how strick mocks lead to overspecification. Imagine that we are creating a simple screen in a Passive View architecture. The first feature that we implement is displaying the message &amp;ldquo;edit&amp;rdquo; when the user clicks the edit button
[Fact] public void ShouldDisplayEditClickMessage() { // Establish context 	MockRepository mockRepository = new MockRepository(); IView view = mockRepository.StrictMock&amp;lt;iview&amp;gt;(); Expect.Call(delegate { view.EditClick += null; }).IgnoreArguments(); mockRepository.Replay(view); // Create sut 	Presenter sut = new Presenter(view); // Setup expectations 	mockRepository.</description>
    </item>
    
    <item>
      <title>Refactoring EffectivityManager</title>
      <link>/post/2008-09-23-refactoring-effectivitymanager/</link>
      <pubDate>Tue, 23 Sep 2008 00:00:00 +0000</pubDate>
      
      <guid>/post/2008-09-23-refactoring-effectivitymanager/</guid>
      <description>A while ago i presented the EffectivityManager. Having used this class for a while i have decided to rename it to Temporal. The implementation of IListis not required anymore because a user is typically only interested in a specific effectivity, not the evolution of the effectivities.
public interface ITemporal&amp;lt;T&amp;gt; { void Modify(T element, DateTime from); IEffectivity&amp;lt;T&amp;gt; GetSnapshot(DateTime validityDate); bool TryGetSnapshot(DateTime validityDate, out IEffectivity&amp;lt;T&amp;gt; effectivity); } In the implementation i have added a constructor that accepts a DiscreteValuesGenerator which makes it possible to create Periods with a resolution of a day instead of seconds.</description>
    </item>
    
    <item>
      <title>About the Specification pattern</title>
      <link>/post/2008-07-22-about-the-specification-pattern/</link>
      <pubDate>Tue, 22 Jul 2008 00:00:00 +0000</pubDate>
      
      <guid>/post/2008-07-22-about-the-specification-pattern/</guid>
      <description>A couple of days ago i mentionned Yves Goeleven&amp;rsquo;s blog as a reference for solutions using DDD principles. Let&amp;rsquo;s have a look at his implementation of the AndSpecification and OrSpecification in Design Patterns &amp;ndash; The Specification Pattern &amp;ndash; Part I
class AndSpecification&amp;lt;T&amp;gt; : CompositeSpecification&amp;lt;T&amp;gt; { public override bool IsSatisfiedBy(T candidate) { bool isSatisfied = true; foreach( ISpecification&amp;lt;T&amp;gt; spec in Specifications) { isSatisfied &amp;amp;= spec.IsSatisfiedBy(candidate); } return isSatisfied; } } class OrSpecification&amp;lt;T&amp;gt; : CompositeSpecification&amp;lt;T&amp;gt; { public override bool IsSatisfiedBy(T obj) { bool isSatisfied = false; foreach( ISpecification&amp;lt;T&amp;gt; spec in Specifications) { isSatisfied |= spec.</description>
    </item>
    
    <item>
      <title>Presenting a generic DiscreteValuesRange</title>
      <link>/post/2008-07-16-presenting-a-generic-discreterange/</link>
      <pubDate>Wed, 16 Jul 2008 00:00:00 +0000</pubDate>
      
      <guid>/post/2008-07-16-presenting-a-generic-discreterange/</guid>
      <description>Let me start with a real world example demonstrating the usefulness of a generic DiscreteValuesRange. Imagine that i run a grid computing business and my clients want to book capacity on the grid for a given period. Before their booking is approved, i have to verify that the client has contracts that allow him to use the system for each day of the booking period. Usually, such a check is implemented as following</description>
    </item>
    
    <item>
      <title>Presenting a generic Effectivity</title>
      <link>/post/2008-05-19-presenting-a-generic-effectivity/</link>
      <pubDate>Mon, 19 May 2008 00:00:00 +0000</pubDate>
      
      <guid>/post/2008-05-19-presenting-a-generic-effectivity/</guid>
      <description>Very often we have to manage objects and their changes over time. Usually we implement this by adding a Range to the data. Martin Fowler has a name for this pattern: Effectivity and i have an implementation for the following interface
public interface IEffectivity&amp;lt;T&amp;gt; : IComparable&amp;lt;ieffectivity&amp;lt;T&amp;gt;&amp;gt; { T Element { get; } IRange&amp;lt;dateTime&amp;gt; ValidityPeriod { get; } bool IsEffectiveOn(DateTime validityDate); } Feel free to download IEffectivity.txt, Effectivity.txt and EffectivityTester.txt.</description>
    </item>
    
    <item>
      <title>Presenting a generic EffectivityManager</title>
      <link>/post/2008-05-19-presenting-a-generic-effectivitymanager/</link>
      <pubDate>Mon, 19 May 2008 00:00:00 +0000</pubDate>
      
      <guid>/post/2008-05-19-presenting-a-generic-effectivitymanager/</guid>
      <description>I&amp;rsquo;ve already presented a Generic Effectivity. Offcourse, managing all these effectivities (versions of data) can be handled in a generic way too. A bit of experience mixed with Patterns for things that change with time allowed me to come up with the following interface
public interface IEffectivityManager&amp;lt;T&amp;gt; : IList&amp;lt;ieffectivity&amp;lt;T&amp;gt;&amp;gt; { IEffectivity&amp;lt;T&amp;gt; Add(T t, DateTime begin); IEffectivity&amp;lt;T&amp;gt; GetSnapshot(DateTime validityDate); bool TryGetSnapshot(DateTime validityDate, out IEffectivity&amp;lt;T&amp;gt; effectivity); } Feel free to download IEffectivityManager.txt, EffectivityManager.</description>
    </item>
    
    <item>
      <title>Presenting a generic Range</title>
      <link>/post/2008-05-17-presenting-a-generic-range/</link>
      <pubDate>Sat, 17 May 2008 00:00:00 +0000</pubDate>
      
      <guid>/post/2008-05-17-presenting-a-generic-range/</guid>
      <description>Quite often i&amp;rsquo;m writing code that compares one value against a range of other values. Most implementations compare the value against the boundaries (smallest and largest in the collection of other values). Having written this sort of code way too much i&amp;rsquo;ve decided to generalize the problem and distill an interface
public interface IRange&amp;lt;T&amp;gt; { T Begin { get; set; } T End { get; set; } bool Includes(T t); bool Includes(IRange&amp;lt;T&amp;gt; range); bool Overlaps(IRange&amp;lt;T&amp;gt; range); } Offcourse, i&amp;rsquo;ve also written implementation.</description>
    </item>
    
  </channel>
</rss>
