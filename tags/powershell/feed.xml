<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PowerShell on Tim Van Wassenhove</title><link>https://timvw.be/tags/powershell/</link><description>Recent content in PowerShell on Tim Van Wassenhove</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 15 Aug 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://timvw.be/tags/powershell/feed.xml" rel="self" type="application/rss+xml"/><item><title>Deploying a Cloud Service to Azure with Octopus</title><link>https://timvw.be/2014/08/15/deploying-a-cloud-service-to-azure-with-octopus/</link><pubDate>Fri, 15 Aug 2014 00:00:00 +0000</pubDate><guid>https://timvw.be/2014/08/15/deploying-a-cloud-service-to-azure-with-octopus/</guid><description>Currently Octopus has limited support to deploy a Cloud Service on Azure. A typical use-case is that you need a different Web.Config file per environment. Simply add the Web.Environment.Config files to your NuGet package and use the following PreDeploy.ps1 script:
# Load unzip support [Reflection.Assembly]::LoadWithPartialName(&amp;#34;System.IO.Compression.FileSystem&amp;#34;) | Out-Null function Unzip($zipFile, $destination) { If (Test-Path $destination){ Remove-Item $destination -Recurse | Out-Null } New-Item -ItemType directory -Force -Path $destination | Out-Null [System.IO.Compression.ZipFile]::ExtractToDirectory($zipFile, $destination) | Out-Null } # Unzip deployment package $CsPkg = &amp;#34;Customer.</description></item><item><title>Multiclean solution</title><link>https://timvw.be/2012/04/26/multiclean-solution/</link><pubDate>Thu, 26 Apr 2012 00:00:00 +0000</pubDate><guid>https://timvw.be/2012/04/26/multiclean-solution/</guid><description>One of my favorite powershell commands when cleaning up:
$RootFolder = &amp;#39;C:\tfs&amp;#39; Get-ChildItem $RootFolder bin -Recurse | Remove-Item -Recurse Get-ChildItem $RootFolder obj -Recurse | Remove-Item -Recurse</description></item><item><title>Force the removal of a file with PowerShell</title><link>https://timvw.be/2011/10/18/force-the-removal-of-a-file-with-powershell/</link><pubDate>Tue, 18 Oct 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/10/18/force-the-removal-of-a-file-with-powershell/</guid><description>Last couple of weeks I have been generating a lot of files (and restricting their ACLs) and today I decided to remove all those files. The problem is that my user account did not have permissions on those files. Here is a small script that will first take ownership of the file, then grants FullControl permissions, and finally removes the file üôÇ
function RemoveFile { param($FileName) &amp;amp;takeown /F $FileName $User = [System.</description></item><item><title>Launch DtExec from PowerShell</title><link>https://timvw.be/2011/07/15/launch-dtexec-from-powershell/</link><pubDate>Fri, 15 Jul 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/07/15/launch-dtexec-from-powershell/</guid><description>Running an SSIS package from PowerShell (using DTExec) can be as simple as:
RunPackage -File &amp;#39;C:\test.dtsx&amp;#39; -DatabaseHost &amp;#39;.&amp;#39; -DatabaseName &amp;#39;TEST&amp;#39;; Here are the functions that make it this simple:
function GetDtExecPath { $DtsPath = (Get-ItemProperty &amp;#39;HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\100\DTS\Setup&amp;#39;).SQLPath; $DtExecPath = (Resolve-Path &amp;#34;$DtsPath\Binn\DTExec.exe&amp;#34;); $DtExecPath; } function GetDtExecPropertyPathValue() { param( $PropertyPath = &amp;#39;&amp;#39;, $Value = &amp;#39;&amp;#39;; ); &amp;#34;$PropertyPath;\`&amp;#34;\`&amp;#34;$Value\`&amp;#34;\`&amp;#34;&amp;#34;; } function RunPackage { param( $DtExecPath = (GetDtExecPath), $File = &amp;#39;test.dtsx&amp;#39; ); $Params = &amp;#34;/FILE $File&amp;#34;; for($i = 0; $i -lt $Args.</description></item><item><title>Set variables in SSIS package at runtime</title><link>https://timvw.be/2011/05/19/set-variables-in-ssis-package-at-runtime/</link><pubDate>Thu, 19 May 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/05/19/set-variables-in-ssis-package-at-runtime/</guid><description>The documentation on dtexec Utility (SSIS Tool) says the following:
/Set propertyPath;value
(Optional). Overrides the configuration of a variable, property, container, log provider, Foreach enumerator, or connection within a package. When this option is used, /Set changes the propertyPath argument to the value specified. Multiple /Set options can be specified.
At first sight this works like a charm but as soon as your value has a space dtexec seems to get confused üôÅ It took me a couple of websearches to find a post that suggests the following:</description></item><item><title>Invoke parameterized stored procedure with PowerShell</title><link>https://timvw.be/2011/03/21/invoke-parameterized-stored-procedure-with-powershell/</link><pubDate>Mon, 21 Mar 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/03/21/invoke-parameterized-stored-procedure-with-powershell/</guid><description>Here is a quick snippet that demonstrates how you can invoke a parametrized stored procedure with PowerShell:
$CreateTraceCommand = $SqlConnection.CreateCommand(); $CreateTraceCommand.CommandType = [System.Data.CommandType] &amp;#34;StoredProcedure&amp;#34;; $CreateTraceCommand.CommandText = &amp;#34;sp_trace_create&amp;#34;; $TraceIdParameter = $CreateTraceCommand.Parameters.Add(&amp;#34;@traceid&amp;#34;, [System.Data.SqlDbType] &amp;#34;Int&amp;#34;); $TraceIdParameter.Direction = [System.Data.ParameterDirection] &amp;#34;Output&amp;#34;; $OptionParameter = $CreateTraceCommand.Parameters.Add(&amp;#34;@options&amp;#34;, [System.Data.SqlDbType] &amp;#34;Int&amp;#34;); $OptionParameter.Value = [int] 2; $TraceFileParameter = $CreateTraceCommand.Parameters.Add(&amp;#34;@tracefile&amp;#34;, [System.Data.SqlDbType] &amp;#34;NVarChar&amp;#34;); $TraceFileParameter.Value = [string] &amp;#34;c:\temp\test&amp;#34;; [void] $CreateTraceCommand.ExecuteNonQuery(); $TraceId = $TraceIdParameter.Value; Write-Host &amp;#34;You created a trace with ```</description></item><item><title>Dynamic scriptblock with PowerShell</title><link>https://timvw.be/2011/03/12/dynamic-scriptblock-with-powershell/</link><pubDate>Sat, 12 Mar 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/03/12/dynamic-scriptblock-with-powershell/</guid><description>Earlier this week i tried to run a command on a remote computer but it did not seem to work:
$name = &amp;#39;tim&amp;#39; $computer = &amp;#39;localhost&amp;#39; Invoke-Command -ComputerName $computer -ScriptBlock { Write-Host &amp;#34;Hello $name&amp;#34; } Because powershell serialises the { Write-Host &amp;ldquo;Hello $name&amp;rdquo; } as a string this ends up at the remote computer as { Write-Host &amp;ldquo;Hello $null&amp;rdquo; }. In order to send our &amp;ldquo;dynamic&amp;quot;command string over the wire we have to make sure it is serialised correctly:</description></item><item><title>Some PowerShell functions to work with SSIS packages</title><link>https://timvw.be/2011/03/12/some-powershell-functions-to-work-with-ssis-packages/</link><pubDate>Sat, 12 Mar 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/03/12/some-powershell-functions-to-work-with-ssis-packages/</guid><description>Here are some powershell functions (using XPath) that come in handy when working with SSIS packages:
function FindConnectionManagerNames { param($fileName) $xml = [xml] (Get-Content $fileName); $ns = New-Object Xml.XmlNamespaceManager $xml.NameTable; $ns.AddNamespace(&amp;#34;DTS&amp;#34;, &amp;#34;www.microsoft.com/SqlServer/Dts&amp;#34;); $xml.SelectNodes(&amp;#34;//DTS:ConnectionManager/DTS:Property[@DTS:Name=&amp;#39;ObjectName&amp;#39;]&amp;#34;, $ns) | Foreach { $_.&amp;#34;#text&amp;#34;; } } function GetConnectionManagerConnectionString { param($fileName, $connectionManagerName) $xml = [xml] (Get-Content $fileName); $ns = New-Object Xml.XmlNamespaceManager $xml.NameTable; $ns.AddNamespace(&amp;#34;DTS&amp;#34;, &amp;#34;www.microsoft.com/SqlServer/Dts&amp;#34;); $path = &amp;#34;//DTS:ConnectionManager[DTS:Property=&amp;#39;$connectionManagerName&amp;#39;]/DTS:ObjectData/DTS:ConnectionManager/DTS:Property[@DTS:Name=&amp;#39;ConnectionString&amp;#39;]&amp;#34; $xml.SelectSingleNode($path, $ns).&amp;#34;#text&amp;#34;; } function FindVariables { param($fileName) $xml = [xml] (Get-Content $fileName); $ns = New-Object Xml.</description></item><item><title>Consume custom SSIS tasks without GAC installation</title><link>https://timvw.be/2011/03/05/consume-custom-ssis-tasks-without-gac-installation/</link><pubDate>Sat, 05 Mar 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/03/05/consume-custom-ssis-tasks-without-gac-installation/</guid><description>For a while i thought that in order to consume a custom SSIS task you had to install the assembly in the GAC. Now i know better üòâ
For the designer (BIDS) you have to copy the files to
C:\Program Files\Microsoft SQL Server\100\DTS\Tasks C:\Program Files\Microsoft SQL Server\100\DTS\PipelineComponents For the runtime (BIDS) you have to copy the files to
C:\Program Files\Microsoft Visual Studio 9.0\Common7\IDE\PrivateAssemblies And for dtexec you have to copy the files to</description></item><item><title>Get current file in PowerShell</title><link>https://timvw.be/2011/01/24/get-current-file-in-powershell/</link><pubDate>Mon, 24 Jan 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/01/24/get-current-file-in-powershell/</guid><description>A while ago i wrote a small script to take care of deployment. Configuring the source folders went as following:
param( $BaseDir = (Get-Location).Path, $WebDir = (Resolve-Path &amp;#34;$BaseDir\web&amp;#34;), $DatabaseDir = (Resolve-Path &amp;#34;$BaseDir\database&amp;#34;) ) The problem with this code is that it only works when your current working directory is set to the location of this script. An administrator (or build system) invokes the script as following:
PS C:\Users\Admin&amp;gt;&amp;amp; &amp;#39;D:\Deployments\20110124\Deploy.ps1&amp;#39;; Because we don&amp;rsquo;t want to annoy the consumer of our script with the burden of making sure he is in the correct directory we modified our code as following:</description></item><item><title>Polling the existence of a file with PowerShell</title><link>https://timvw.be/2011/01/24/polling-the-existence-of-a-file-with-powershell/</link><pubDate>Mon, 24 Jan 2011 00:00:00 +0000</pubDate><guid>https://timvw.be/2011/01/24/polling-the-existence-of-a-file-with-powershell/</guid><description>Sometimes you run into a situations where a given task spawns a separate thread and completes it&amp;rsquo;s work on that separate thread. Eg: sending a bit XMLA to SQL Server Analysis Services with Microsoft.AnalysisServices.Deployment.exe and then waiting for the processing to be completed. Anyway, here is a simple function that will wait untill a given file exists:
function WaitForFile($File) { while(!(Test-Path $File)) { Start-Sleep -s 10; } }</description></item><item><title>Convert AAC/M4A files to MP3 with VLC and PowerShell</title><link>https://timvw.be/2010/11/20/convert-aac/m4a-files-to-mp3-with-vlc-and-powershell/</link><pubDate>Sat, 20 Nov 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/11/20/convert-aac/m4a-files-to-mp3-with-vlc-and-powershell/</guid><description>Here is a way to convert your AAC/M4A files to MP3 using VLC media player:
vlc.exe -I dummy old.m4a :sout=#transcode{acodec=$codec,vcodec=dummy}:standard{access=file,mux=raw,dst=new.mp3} vlc://quit Let&amp;rsquo;s wrap this command in a bit of PowerShell:
function ConvertToMp3([switch] $inputObject, [string] $vlc = &amp;#39;C:\Program Files\VideoLAN\VLC\vlc.exe&amp;#39;) { PROCESS { $codec = &amp;#39;mp3&amp;#39;; $oldFile = $_; $newFile = $oldFile.FullName.Replace($oldFile.Extension, &amp;#34;.$codec&amp;#34;); &amp;amp;&amp;#34;$vlc&amp;#34; -I dummy &amp;#34;$oldFile&amp;#34; &amp;#34;:sout=#transcode{acodec=$codec,vcodec=dummy}:standard{access=file,mux=raw,dst=\`&amp;#39;$newFile\`&amp;#39;}&amp;#34; vlc://quit | out-null; #Only remove source files when you are sure that the conversion works as you want #Remove-Item $oldFile; } } And now we can use this function for *all* m4a files in a given folder:</description></item><item><title>Configure Visual Studio 2010 environment in PowerShell</title><link>https://timvw.be/2010/11/17/configure-visual-studio-2010-environment-in-powershell/</link><pubDate>Wed, 17 Nov 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/11/17/configure-visual-studio-2010-environment-in-powershell/</guid><description>Instead of using the &amp;ldquo;Visual Studo Command Prompt (2010)&amp;rdquo; i wanted to use PowerShell instead. I found this post which does it for VS2008. Extending it for VS2010 was pretty easy:
function SetVS2008() { $vs90comntools = (Get-ChildItem env:VS90COMNTOOLS).Value $batchFile = [System.IO.Path]::Combine($vs90comntools, &amp;#34;vsvars32.bat&amp;#34;) Get-Batchfile $BatchFile [System.Console]::Title = &amp;#34;Visual Studio 2008 Windows PowerShell&amp;#34; } function SetVS2010() { $vs100comntools = (Get-ChildItem env:VS100COMNTOOLS).Value $batchFile = [System.IO.Path]::Combine($vs100comntools, &amp;#34;vsvars32.bat&amp;#34;) Get-Batchfile $BatchFile [System.Console]::Title = &amp;#34;Visual Studio 2010 Windows PowerShell&amp;#34; } function Get-Batchfile($file) { $cmd = &amp;#34;\`&amp;#34;$file\`&amp;#34; &amp;amp; set&amp;#34; cmd /c $cmd | Foreach-Object { $p, $v = $_.</description></item><item><title>Load all script files at PowerShell startup</title><link>https://timvw.be/2010/11/17/load-all-script-files-at-powershell-startup/</link><pubDate>Wed, 17 Nov 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/11/17/load-all-script-files-at-powershell-startup/</guid><description>These days i have quite some scripts files that i want to be loaded each time i launch PowerShell. Windows PowerShell Profiles teaches me where i should store my $profile. Here is what it looks like:
# Lookup powershell scripts location $UserProfile = (Get-ChildItem Env:UserProfile).Value; $ScriptFolder = &amp;#34;$UserProfile\My documents\WindowsPowerShell&amp;#34;; # Source all .ps1 files in PowerShell profile folder Get-ChildItem $ScriptFolder -name -include &amp;#39;*.ps1&amp;#39; -exclude &amp;#39;profile.ps1&amp;#39; | foreach { (. &amp;#34;$ScriptFolder\$_&amp;#34;) }; # Configure environment for VS2010 SetVS2010;</description></item><item><title>Get variable value from variable with PowerShell</title><link>https://timvw.be/2010/11/11/get-variable-value-from-variable-with-powershell/</link><pubDate>Thu, 11 Nov 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/11/11/get-variable-value-from-variable-with-powershell/</guid><description>Sometimes you only know at runtime in which variable a certain value is stored. Let me clarify with an example:
$tim = 30; $evy = 24; $name = Read-Host &amp;#34;Enter your name&amp;#34;; In essence, if $name equals tim we want to use $tim and if $name equals evy we want to use $evy. This can be achieved with Get-Variable:
$age = Get-Variable $name -valueOnly; Write-Host &amp;#34;Your age is $age&amp;#34;;</description></item><item><title>Update ConfigurationStrings in SSIS package with PowerShell</title><link>https://timvw.be/2010/11/11/update-configurationstrings-in-ssis-package-with-powershell/</link><pubDate>Thu, 11 Nov 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/11/11/update-configurationstrings-in-ssis-package-with-powershell/</guid><description>Here are some functions that allow you to update ConfigurationStrings in a SSIS package (dtsx) using PowerShell:
function UpdateConfigurationStrings($file) { $xml = [xml] (Get-Content $file); $ns = New-Object Xml.XmlNamespaceManager $xml.NameTable; $ns.AddNamespace(&amp;#34;DTS&amp;#34;, &amp;#34;www.microsoft.com/SqlServer/Dts&amp;#34;); UpdateConfigurationNodes $xml $ns; Set-Content $file $xml.OuterXml; } function UpdateConfigurationNodes($xml, $ns) { $selectConfigurationNodes = &amp;#34;//DTS:Configuration&amp;#34;; $xml.SelectNodes($selectConfigurationNodes, $ns) | foreach { UpdateConfigurationNode $_ $ns; }; } function UpdateConfigurationNode($configurationNode, $ns) { $selectConfigurationString = &amp;#34;./DTS:Property[@DTS:Name=&amp;#39;ConfigurationString&amp;#39;]&amp;#34;; $configurationStringNode = $configurationNode.SelectSingleNode($selectConfigurationString, $ns); $oldConfigurationStringValue = $configurationStringNode.&amp;#39;#text&amp;#39;; $newConfigurationStringValue = GetNewConfigurationStringValue $oldConfigurationStringValue; $configurationStringNode.</description></item><item><title>Invoke PowerShell script from MSBuild</title><link>https://timvw.be/2010/11/07/invoke-powershell-script-from-msbuild/</link><pubDate>Sun, 07 Nov 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/11/07/invoke-powershell-script-from-msbuild/</guid><description>Here is a small MSBuild target that allows you to invoke a PowerShell script, eg: powershell.exe &amp;amp; &amp;lsquo;script.ps1&amp;rsquo; -SomeParam &amp;lsquo;x&amp;rsquo;
&amp;lt;Target Name=&amp;#34;InvokePowerShell&amp;#34;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;PowerShellCommand&amp;gt;&amp;#34;$(PowerShellTool)&amp;#34; &amp;#34;&amp;amp; &amp;#39;$(ScriptFile)&amp;#39; -SomeParam &amp;#39;$(SomeParam)&amp;#39; &amp;#34;&amp;lt;/PowerShellCommand&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Exec Command=&amp;#34;$(PowerShellCommand)&amp;#34; /&amp;gt; &amp;lt;/Target&amp;gt;</description></item><item><title>Modify a text file with PowerShell</title><link>https://timvw.be/2010/11/07/modify-a-text-file-with-powershell/</link><pubDate>Sun, 07 Nov 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/11/07/modify-a-text-file-with-powershell/</guid><description>A while ago i wanted to update a connection string in a configuration file. My first attempt was the following:
Get-Content $File | Foreach { $_ -Replace &amp;#34;Source&amp;gt;(.*?)&amp;lt;&amp;#34;, &amp;#34;Source&amp;gt;$New&amp;lt;&amp;#34; } | Set-Content $File; Running this scripts leads to the following error: &amp;ldquo;Set-Content : The process cannot access the file because it is being used by another process.&amp;rdquo; In order to avoid this you can complete the read operation before you start writing as following:</description></item><item><title>Update all repositories with Powershell</title><link>https://timvw.be/2010/10/25/update-all-repositories-with-powershell/</link><pubDate>Mon, 25 Oct 2010 00:00:00 +0000</pubDate><guid>https://timvw.be/2010/10/25/update-all-repositories-with-powershell/</guid><description>I typically store the repositories i am working on under D:\Code. Each morning i had to right click on each of those folders and select &amp;lsquo;SVN Update&amp;rsquo; using Tortoise SVN. Today i decided there had to be a better way to accomplish this tedious task:
dir d:\code | foreach { svn update $_.FullName } And in case you really like tortoise, you can do the following:
dir c:\code | foreach { tortoiseproc /command:update /closeonend:1 /path:$($_.</description></item></channel></rss>