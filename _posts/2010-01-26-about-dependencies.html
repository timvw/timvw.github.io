---
layout: post
status: publish
published: true
title: About dependencies
author:
  display_name: timvw
  login: admin
  email: tim@timvw.be
  url: http://timvw.myopenid.com/
author_login: admin
author_email: tim@timvw.be
author_url: http://timvw.myopenid.com/
wordpress_id: 1635
wordpress_url: http://www.timvw.be/?p=1635
date: '2010-01-26 08:38:23 +0100'
date_gmt: '2010-01-26 07:38:23 +0100'
categories: []
tags:
- Information Technology
comments: []
---
<p>This weekend i noticed a couple of posts by Uncle Bob trying to get some discussions going. In <a href="http:&#47;&#47;blog.objectmentor.com&#47;articles&#47;2010&#47;01&#47;23&#47;mocking-mocking-and-testing-outcomes">Mocking Mocking and Testing Outcomes<&#47;a> at some point he generates a fake of some class<&#47;p></p>
<blockquote><p>&ldquo;Oh, ick!&rdquo; you say. Yes, I agree it&rsquo;s a lot of code. On the other hand, it took me just a single keystroke on my IDE to generate all those dummy methods. (In IntelliJ it was simply command-I to implement all unimplemented methods.) So it wasn&rsquo;t particularly hard. And, of course, I can put this code somewhere where nobody had to look at it unless they want to. It has the advantage that anybody who knows Java can understand it, and can look right at the methods to see what they are returning. No &ldquo;special&rdquo; knowledge of the mocking framework is necessary.<&#47;blockquote></p>
<p>So adding a lot of generated code, which no-one should ever look at, is better than a mocking framework? Hahaha, why would i want to repeat myself creating all those fake objects? (<a href="http:&#47;&#47;c2.com&#47;cgi&#47;wiki?DontRepeatYourself">DRY<&#47;a>)<&#47;p></p>
<p>Another problem that i have with his example is the fact that the 'dependency' has a ton of methods that are not used by the consumer, so it makes me wonder: why are those methods there? Define an interface for the required methods, and have your consumer use that interface instead. This way you don't have to look at those unused methods which only clutter the API.<&#47;p></p>
<p>A second read made it clear that Uncle Bob is talking about unit-tests, which are typically implemented as state-based tests. In case you're doing integration tests, you will have (more) dependencies and want to verify the interaction between your system under test and the dependencies. And that is (imho) the scenario where mocking frameworks really shine :)<&#47;p></p>
