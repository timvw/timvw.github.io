---
layout: post
status: publish
published: true
title: Reading and writing unmanged structs from binary files
author:
  display_name: timvw
  login: admin
  email: tim@timvw.be
  url: http://timvw.myopenid.com/
author_login: admin
author_email: tim@timvw.be
author_url: http://timvw.myopenid.com/
wordpress_id: 149
wordpress_url: http://www.timvw.be/reading-and-writing-binary-files/
date: '2007-01-20 22:00:12 +0100'
date_gmt: '2007-01-20 20:00:12 +0100'
categories: []
tags:
- C#
comments: []
---
<p>I still remember one of the first tasks during my internship (At a software shop that still used Visual Studio 6 as development environment) last year: Develop a GUI application using .Net that allows the user to manipulate data stored in a binary file which was generated by c&#47;c++ program. As a newcomer to C# programming i just couldn't find the right attributes to <a href="http:&#47;&#47;msdn2.microsoft.com&#47;en-us&#47;library&#47;04fy9ya1.aspx">Marshal<&#47;a> the following structs:<&#47;p><br />
[code lang="cpp"]struct test1 {<br />
 char name[9];<br />
 int score;<br />
};</p>
<p>struct test2 {<br />
 test1 items[10];<br />
}[&#47;code]</p>
<p>After a couple of days they wanted me to deliver a product, so i decided to stop experimenting and wrote the application in C++ (<a href="http:&#47;&#47;www.timvw.be&#47;reading-unmanaged-structs-with-net&#47;">Example<&#47;a>). Since i don't like unanswered questions, i decided to give it another try this afternoon... It didn't take long to come up with the following:<&#47;p><br />
[code lang="csharp"]<br />
[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi, Pack=4)]<br />
struct Test1<br />
{<br />
 [MarshalAs(UnmanagedType.ByValTStr, SizeConst=9)]<br />
 public string Name;<br />
 public int Score;<br />
}</p>
<p>[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi, Pack=4)]<br />
struct Test2<br />
{<br />
 [MarshalAs(UnmanagedType.ByValArray, SizeConst=10)]<br />
 public Test1[] Items;<br />
}</p>
<p>static object Read(Stream stream, Type t)<br />
{<br />
 byte[] buffer = new byte[Marshal.SizeOf(t)];<br />
 for (int read = 0; read < buffer.Length; read += stream.Read(buffer, read, buffer.Length)) ;<br />
 GCHandle gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);<br />
 object o = Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), t);<br />
 gcHandle.Free();<br />
 return o;<br />
}</p>
<p>static void Write(Stream stream, object o)<br />
{<br />
 byte[] buffer = new byte[Marshal.SizeOf(o.GetType())];<br />
 GCHandle gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);<br />
 Marshal.StructureToPtr(o, gcHandle.AddrOfPinnedObject(), true);<br />
 stream.Write(buffer, 0, buffer.Length);<br />
 gcHandle.Free();<br />
}</p>
<p>static void Main(string[] args)<br />
{<br />
 Test1 test1 = new Test1();<br />
 test1.Name = "timvw";<br />
 test1.Score = 100;</p>
<p> using (FileStream fileStream = new FileStream(@"c:\test.dat", FileMode.OpenOrCreate))<br />
 {<br />
  Write(fileStream, test1);<br />
  fileStream.Seek(0, SeekOrigin.Begin);<br />
  Test1 test2 = (Test1) Read(fileStream, typeof(Test1));<br />
  Console.WriteLine("Name: {0} Score: {1}", test2.Name, test2.Score);<br />
 }</p>
<p> Console.Write("{0}Press any key to continue...", Environment.NewLine);<br />
 Console.ReadKey();<br />
}[&#47;code]</p>
