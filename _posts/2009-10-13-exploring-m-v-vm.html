---
layout: post
status: publish
published: true
title: Exploring M-V-VM
author:
  display_name: timvw
  login: admin
  email: tim@timvw.be
  url: http://timvw.myopenid.com/
author_login: admin
author_email: tim@timvw.be
author_url: http://timvw.myopenid.com/
wordpress_id: 1403
wordpress_url: http://www.timvw.be/?p=1403
date: '2009-10-13 16:10:10 +0200'
date_gmt: '2009-10-13 15:10:10 +0200'
categories: []
tags:
- Patterns
- WPF
- Silverlight
comments: []
---
<p>A couple of years ago a collegue recommended <a href="http:&#47;&#47;www.amazon.com&#47;Data-Binding-Windows-Forms-2-0&#47;dp&#47;032126892X">Data Binding with Windows Forms 2.0: Programming Smart Client Data Applications with .NET<&#47;a> and i noticed that my code started to gravitate towards an <a href="http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Model_View_ViewModel">Model-View-ViewModel<&#47;a> architecture. Due to shortcomings and painful experiences i gave up on databinding and began to use <a href="http:&#47;&#47;martinfowler.com&#47;eaaDev&#47;PassiveScreen.html">Passieve View<&#47;a> instead.<&#47;p></p>
<p>Passive View doesn't work (well) with smart views so i decided to give M-V-VM another because i really wanted to leverage WPF's rich support for databinding.<&#47;p></p>
<p>The key difference between M-V-VM and Passive View is, imho, the fact that the ViewModel is unaware of the View unlike Passive View where the Presenter knows about the (simple) View.<&#47;p></p>
<p>When we test a Presenter i notice that we end up writing interaction based tests (assertions on a mocked view) and when we test a ViewModel we end up writing state-based tests instead.<&#47;p></p>
